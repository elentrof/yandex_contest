# Пещера представлена кубом, разбитым на N частей по каждому измерению (то есть на N3 кубических клеток). 
# Каждая клетка может быть или пустой, или полностью заполненной камнем. Исходя из положения спелеолога в пещере, требуется найти, 
# какое минимальное количество перемещений по клеткам ему требуется, чтобы выбраться на поверхность. Переходить из клетки в клетку можно, только если они обе свободны и имеют общую грань.

# Формат ввода
# В первой строке содержится число N (1 ≤ N ≤ 30). Далее следует N блоков. Блок состоит из пустой строки и N строк по N символов:
#  # - обозначает клетку, заполненную камнями, точка - свободную клетку. Начальное положение спелеолога обозначено заглавной буквой S. 
#  Первый блок представляет верхний уровень пещеры, достижение любой свободной его клетки означает выход на поверхность. Выход на поверхность всегда возможен.

# Формат вывода
# Вывести одно число - длину пути до поверхности.

f = open('input.txt', 'r')
n = int(f.readline())

gf = [[[0 for k in range(n)] for j in range(n)] for i in range(n)]
mas = [[[0 for k in range(n)] for j in range(n)] for i in range(n)]

for z in range(n):
  f.readline()
  for x in range(n):
    str_ = f.readline().strip()
    for y in range(n):
      # отправная точка
      if str_[y] == 'S':
        posS = [z,x,y]
        gf[z][x][y] = 2
        mas[z][x][y] = 0
      elif str_[y] == '#':
        gf[z][x][y] = 1
      else:
        gf[z][x][y] = 0

# проверка на то, что не вышли из куба
def correct(z, x, y):
  if z < 0 or x < 0 or y < 0:
    return False;
  if z==n or x==n or y==n:
    return False;
  return True;

# возможные сдвиги по осям
moveZ = [-1,1, 0,0, 0,0]
moveX = [0 ,0, 0,0,-1,1]
moveY = [0 ,0,-1,1, 0,0]

# обход в ширину
def bfs():
  steps = -1;
  queue = []
  queue.insert(0, posS);
  while queue:
    cur = queue[-1]
    queue.pop()
    if cur[0] == 0:
      steps = mas[cur[0]][cur[1]][cur[2]]
      break
    for i in range(0, 6):
      z = cur[0] + moveZ[i]
      x = cur[1] + moveX[i]
      y = cur[2] + moveY[i]

      if correct(z, x, y) and gf[z][x][y] == 0 and mas[z][x][y] == 0:
        mas[z][x][y] = mas[cur[0]][cur[1]][cur[2]] + 1; 
        queue.insert(0, ([z,x,y]))

  print(steps)


bfs() 
